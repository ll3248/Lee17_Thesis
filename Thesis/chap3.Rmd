---
header-includes:
- \usepackage{graphicx,latexsym}
- \usepackage{amssymb,amsthm,amsmath}
- \usepackage{longtable,booktabs,setspace}
---

<!--
You can delete the header-includes (lines 3-6 above) if you like and also the chunk below since it is loaded in the skeleton.Rmd file.  They are included so that chap3.Rmd will compile by itself when you hit Knit PDF.
-->

```{r include_packages_2, include = FALSE}
# This chunk ensures that the acstats package is
# installed and loaded. This acstats package includes
# the template files for the thesis and also two functions
# used for labeling and referencing
if(!require(devtools))
  install.packages("devtools", repos = "http://cran.rstudio.com")
if(!require(dplyr))
    install.packages("dplyr", repos = "http://cran.rstudio.com")
if(!require(ggplot2))
    install.packages("ggplot2", repos = "http://cran.rstudio.com")
if(!require(acstats)){
  library(devtools)
  devtools::install_github("Amherst-Statistics/acstats")
  }
library(acstats)
```


```{r setupch3, include = FALSE}
library(sand)
library(igraph)
library(network)
library(sna)
library(statnet)
library(ergm)
library(xtable)

options(xtable.comment = FALSE)
options(digits = 4)
```

# Simulation Study

We will use a subset of the Facebook network for our analysis. We fit graph models to the observed network and assess each model's accuracy by comparing the network statistics of the observed network to the graphs generated by the models. 

## Description of the Dataset 

This Facebook network was compiled by Stanford University and was accessed through the Stanford Large Network Data Collection (SNAP). For more information, please see @snapnets. Our subset of the Facebook network was presented as an edge list. The social network is one giant component composed of $4039$ vertices and $88234$ edges, which represent $4039$ anonymous users and the $88234$ connections between them, respectively.[^6] This network is simple and undirected, and we believe that the network consists of established, mutual friendships. The first column of values in Table 3.1 below describes some characteristics of this network. We use the `igraph`, `sna`, `network`, `ergm`, and `statnet` packages in `R` and `R-Studio` for this study.[^7]

[^6]: Some of our network statistics that we calculated in `R` did not match those shown in the SNAP website. For example, we calculated the diameter and transitivity of this Facebook component to be $17$ and $0.617$, respectively. However, the SNAP website reports the diameter and "average clustering coefficient" to be $8$ and $0.6055$, respectively. However, other values, such as vertex and edge count, as well as the number of triangles, are equal. While SNAP's algorithm used to calculate their network statistics is unclear, for the purposes of this simulation study, we will be using the values that we calculated from the Facebook component to compare with those generated from our graph models. 

[^7]: See @igraphpackage, @butts2008social, @networkpackagemanual, @networkpackagearticle, @ergmpackagemanual, @ergmpackagearticle,  @handcock_statnet:_2008, @statnetpackagemanual, @statnetpackagearticle, and @intergraphpackagemanual for more details about these packages.

```{r loadfbdata, message = FALSE, echo = FALSE, eval = TRUE}
setwd("~/STAT495-Lee/LeeThesis/data")

#edge list
facebookcombined <- read.table(gzfile("facebook_combined.txt.gz"), 
                               header = F)

#igraph object
fbel <- graph.data.frame(facebookcombined)
```

```{r fbeldescstats, message = FALSE, echo = FALSE, eval = FALSE}
length(unique(c(facebookcombined$V2, facebookcombined$V1))); 
vcount(fbel)
#number of vertices: 4039
nrow(facebookcombined); ecount(fbel)
#number of edges: 88234
sum(count_triangles(fbel))/3 
#number of unique triangles (up to ordering): 1612010

transitivity(fbel, type="localaverage") #0.6170038
diameter(fbel) #17
average.path.length(fbel) #4.337744

mean(igraph::degree(fbel)) 
#average degree centrality: 43.69101
mean(igraph::betweenness(fbel)) 
#average betweenness centrality: 2072.642
mean(igraph::closeness(fbel)) 
#average closeness centrality: 8.881448e-08
mean(igraph::eigen_centrality(fbel)$vector) 
#average eigenvector centrality 0.04047316
```

```{r fbelplot, eval = FALSE, echo = FALSE, include = FALSE}
plot(fbel, 
     edge.arrow.size = 0, 
     edge.width = 0.05, 
     vertex.label = NA, 
     vertex.size = 5)
```

![Overview of our component of the Facebook network](figure/31fbelplot.pdf)

## Generating Random Graphs

For each model, we create graphs of parable magnitude using some of the information calculated from the our Facebook network. We compare selected statistical network statistics of the Facebook network with that of the graphs we generate to see if the observed network and the simulated graphs have similar characteristics. In the sections below, we explain the algorithm, or steps, to simulate one random graph for each model in the sections below. We simulate $1000$ random graphs for each model and record the statistics such as transitivity, diameter, and average centrality values. Because we have $1000$ values--one for each random graph for each model--we can obtain a distribution of these values or a table of average values. 

### Using the Erdős-Rényi Model

Recall that the Erdős-Rényi model takes in only two parameters, which are the number of vertices, $N_{V}$, and the fixed probability of edge forming between any two different vertices, $p$. The number of vertices is already given as $4039$, but to find the probability, we estimate this by taking the number of observed edges and dividing it by the number of possible edges. For a graph $G$, this estimated probability, $\hat{p}$, is
$$\hat{p} = \frac {N_{E}} {{N_{V} \choose 2}},$$
where $N_{E}$ is the number of edges in  $G$ and $N_{V}$ is the number of vertices in $G$. Our estimated probability $\hat{p}$ for this Facebook network is then $\frac {88234} {{4039 \choose 2}}$, or approximately $0.011$. Thus, in order to simulate one graph from this model, we must look at every possible edge among the $4039$ vertices and determine if an edge will form based on the given probability. 

```{r erdosrenyisim, eval = FALSE, echo = FALSE}
set.seed(499)

numsim <- 1000

g.er.fbel.ecount <- rep(NA, numsim)
g.er.fbel.coef <- rep(NA, numsim)
g.er.fbel.apl <- rep(NA, numsim)
g.er.fbel.dia <- rep(NA, numsim)
g.er.fbel.avgdeg <- rep(NA, numsim)
g.er.fbel.avgbtwcen <- rep(NA, numsim)
g.er.fbel.avgclocen <- rep(NA, numsim)
g.er.fbel.avgeigveccen <- rep(NA, numsim)

#probability used in for-loop below
p = ecount(fbel)/choose(vcount(fbel), 2)

for (i in 1:numsim) {
  # n = number of vertices, p = probability of a link
  #p is calculated as number of edges over number of possible edges
  #p is then (4039 choose 2) as calculated above 
  #igraph object
  g.er.fbel <- erdos.renyi.game(n = vcount(fbel), p)
  
  #observe the network statistics for this simulated graph
  g.er.fbel.ecount[i] <- 
    ecount(g.er.fbel)
  g.er.fbel.coef[i] <- 
    transitivity(g.er.fbel, type="localaverage")
  g.er.fbel.apl[i] <- 
    average.path.length(g.er.fbel)
  g.er.fbel.dia[i] <- 
    diameter(g.er.fbel)
  g.er.fbel.avgdeg[i] <- 
    mean(igraph::degree(g.er.fbel))
  g.er.fbel.avgbtwcen[i] <- 
    mean(igraph::betweenness(g.er.fbel))
  g.er.fbel.avgclocen[i] <- 
    mean(igraph::closeness(g.er.fbel))
  g.er.fbel.avgeigveccen[i] <- 
    mean(igraph::eigen_centrality(g.er.fbel)$vector)
}

#save values as dataframe
g.er.fbel <- 
  as.data.frame(cbind(g.er.fbel.ecount, g.er.fbel.coef,
                      g.er.fbel.apl, g.er.fbel.dia, 
                      g.er.fbel.avgdeg,
                      g.er.fbel.avgbtwcen, 
                      g.er.fbel.avgclocen, 
                      g.er.fbel.avgeigveccen))

mean(g.er.fbel.coef) #0.01082603
sd(g.er.fbel.coef) #0.000101139
confint(g.er.fbel.coef)

mean(g.er.fbel.apl) #2.605739
sd(g.er.fbel.apl) #0.001976112

mean(g.er.fbel.dia) #3.956
sd(g.er.fbel.dia) #0.2051977

mean(g.er.fbel.avgdeg) #43.69406
sd(g.er.fbel.avgdeg) #0.143238

mean(g.er.fbel.avgbtwcen) #3241.987
sd(g.er.fbel.avgbtwcen) #3.989771

mean(g.er.fbel.avgclocen) #9.507038e-05
sd(g.er.fbel.avgclocen) #7.229988e-08

mean(g.er.fbel.avgeigveccen) #0.6202335
sd(g.er.fbel.avgeigveccen) #0.02240826
```


### Using the Watts-Strogatz Model

Recall that the Watts-Strogatz model takes in the following parameters: the number of vertices $N_{V}$, the number of starting neighbors $r$, and the probability of an edge to be rewired or the probability for some shortcut to be added $p$. However, instead of using a fixed probability, we will instead randomly add edges until we have approximately the same number as our observed network. So, in this situation, $p = 0$. We start with a circular model with $4039$ vertices and assign a number of edges to the vertices equal to the smallest degree seen in our Facebook network (which we find to be $1$). This is our starting number of neighbors for each vertex. We then randomly add edges equal to the difference between the our starting model and the observed network. That is, we add in $88234 - 4039 = 84195$ edges. Finally, we simplify our simulated graph to eliminate multi-edges and loops.  Since there are $4039 \choose 2$ edges to choose from, intuitively, we can see that having many multi-edges or loops will be infrequent. This makes up one simulated graph from the model. 

```{r wattsstrogatzsim, eval = FALSE, echo = FALSE}
set.seed(499)

numsim <- 1000

g.ws.fbel.ecount <- rep(NA,numsim)
g.ws.fbel.coef <- rep(NA, numsim)
g.ws.fbel.apl <- rep(NA, numsim)
g.ws.fbel.dia <- rep(NA, numsim)
g.ws.fbel.avgdeg <- rep(NA, numsim)
g.ws.fbel.avgbtwcen <- rep(NA, numsim)
g.ws.fbel.avgclocen <- rep(NA, numsim)
g.ws.fbel.avgeigveccen <- rep(NA, numsim)

for (i in 1:numsim) {
  #create a lattice with the same number of vertices as 'fbel'
  #let the starting number of neighbors be 
  #equal to the minimum vertex degree of 'fbel'
  g.ws.fbel <- watts.strogatz.game(dim = 1, size = vcount(fbel), 
                                   nei = min(degree(fbg)), p = 0)
  
  #generate list of random vertex values to add edges to lattice
  #each pair in the list represents one random edge
  randomedgepairs <- sample(1:vcount(fbel), 
                            2*(ecount(fbel)-vcount(fbel)), 
                            replace=TRUE)
  g.ws.fbel.pre <- add_edges(g.ws.fbel, randomedgepairs)
    
  
  #igraph object
  g.ws.fbel <- simplify(g.ws.fbel.pre)
  
  #observe the network statistics for this simulated graph
  g.ws.fbel.ecount[i] <- 
    ecount(g.ws.fbel)
  g.ws.fbel.coef[i] <- 
    transitivity(g.ws.fbel, type="localaverage")
  g.ws.fbel.apl[i] <- 
    average.path.length(g.ws.fbel)
  g.ws.fbel.dia[i] <- 
    diameter(g.ws.fbel)
  g.ws.fbel.avgdeg[i] <- 
    mean(igraph::degree(g.ws.fbel))
  g.ws.fbel.avgbtwcen[i] <- 
    mean(igraph::betweenness(g.ws.fbel))
  g.ws.fbel.avgclocen[i] <- 
    mean(igraph::closeness(g.ws.fbel))
  g.ws.fbel.avgeigveccen[i] <- 
    mean(igraph::eigen_centrality(g.ws.fbel)$vector)
}

#save values as dataframe
g.ws.fbel <- 
  as.data.frame(cbind(g.ws.fbel.ecount, g.ws.fbel.coef,
                      g.ws.fbel.apl, g.ws.fbel.dia, 
                      g.ws.fbel.avgdeg, 
                      g.ws.fbel.avgbtwcen, 
                      g.ws.fbel.avgclocen, 
                      g.ws.fbel.avgeigveccen))

mean(g.ws.fbel.coef)#0.01073166
sd(g.ws.fbel.coef) #9.135127e-05

mean(g.ws.fbel.apl) #2.609323
sd(g.ws.fbel.apl) #0.000193598

mean(g.ws.fbel.dia) #3.95
sd(g.ws.fbel.dia) #0.218054

mean(g.ws.fbel.avgdeg) #43.44555
sd(g.ws.fbel.avgdeg) #0.01105388

mean(g.ws.fbel.avgbtwcen) #3249.223
sd(g.ws.fbel.avgbtwcen) # 0.3908744

mean(g.ws.fbel.avgclocen) #9.493807e-05
sd(g.ws.fbel.avgclocen) #7.319204e-09

mean(g.ws.fbel.avgeigveccen) #0.6234877
sd(g.ws.fbel.avgeigveccen) #0.02269783
```


### Using ERGMs

We consider four different ERGMs--which we label as ERGM 1a, ERGM 2a, ERGM 2b, and ERGM 3a. ERGM 1a takes in only the most basic parameter: edges. In Chapter 2, we have already shown its relationship to the Erdős-Rényi model. ERGM 2a and 2b both take in two parameters: edges and triangles for 2a, and edges and k-stars (of size $3$) for 2b. Lastly, ERGM 3a, takes in all three parameters: edges, triangles, and k-stars (of size $3$). Similar to linear regression, adding in more parameters will allow the ERGM to fit more closely to the observed network but at the cost of greater complexity. We do not consider models that only consist of just the triangle parameter or just the k-star parameter. This is because information about k-stars and triangles are based on some knowledge about edges anyway. After fitting ERGMs with the desired parameters (via maximum likelihood or MCMC), we begin simulating random graphs from each model. 

```{r ergmmods, eval = FALSE, echo = FALSE}
# needs an object of class network
# uses `fbg`, a network object

## one parameter: edges
# this should be the same as Erdos-Renyi
# set the seed for reproducible analysis 
set.seed(499)

# model 1a
g.ergm1a.fbg <- ergm(fbg ~ edges)

numsim = 1000
set.seed(499)

g.ergm1a.fbg.sim.ecount <- rep(NA, numsim)
g.ergm1a.fbg.sim.coef <- rep(NA, numsim)
g.ergm1a.fbg.sim.apl <- rep(NA, numsim)
g.ergm1a.fbg.sim.dia <- rep(NA, numsim)
g.ergm1a.fbg.sim.avgdeg <- rep(NA, numsim)
g.ergm1a.fbg.sim.avgbtwcen <- rep(NA, numsim)
g.ergm1a.fbg.sim.avgclocen <- rep(NA, numsim)
g.ergm1a.fbg.sim.avgeigveccen <- rep(NA, numsim)

for (i in 1:numsim) {
  #simulate graphs from ergms model one at a time
  #convert to igraph object
  g.ergm.fbg.sim.convert <- asIgraph(simulate(g.ergm1a.fbg, nsim = 1))
  
  #observe the network statistics for this simulated graph
  g.ergm1a.fbg.sim.ecount[i] <- ecount(g.ergm.fbg.sim.convert)
  g.ergm1a.fbg.sim.coef[i] <- 
    transitivity(g.ergm.fbg.sim.convert, type="localaverage")
  g.ergm1a.fbg.sim.apl[i] <- 
    average.path.length(g.ergm.fbg.sim.convert)
  g.ergm1a.fbg.sim.dia[i] <- diameter(g.ergm.fbg.sim.convert)
  g.ergm1a.fbg.sim.avgdeg[i] <- 
    mean(igraph::degree(g.ergm.fbg.sim.convert))
  g.ergm1a.fbg.sim.avgbtwcen[i] <- 
    mean(igraph::betweenness(g.ergm.fbg.sim.convert))
  g.ergm1a.fbg.sim.avgclocen[i] <- 
    mean(igraph::closeness(g.ergm.fbg.sim.convert))
  g.ergm1a.fbg.sim.avgeigveccen[i] <- 
    mean(igraph::eigen_centrality(g.ergm.fbg.sim.convert)$vector)
}

g.ergm1a.fbg.sim.df <- 
  as.data.frame(cbind(g.ergm1a.fbg.sim.ecount, g.ergm1a.fbg.sim.coef, 
                      g.ergm1a.fbg.sim.apl, g.ergm1a.fbg.sim.dia,
                      g.ergm1a.fbg.sim.avgdeg, 
                      g.ergm1a.fbg.sim.avgbtwcen,
                      g.ergm1a.fbg.sim.avgclocen,
                      g.ergm1a.fbg.sim.avgeigveccen))

mean(g.ergm1a.fbg.sim.coef) #0.3696413
sd(g.ergm1a.fbg.sim.coef) #0.001246206

mean(g.ergm1a.fbg.sim.apl) #2.885094
sd(g.ergm1a.fbg.sim.apl) #0.004316369

mean(g.ergm1a.fbg.sim.dia) #5.216
sd(g.ergm1a.fbg.sim.dia) #0.4117202

mean(g.ergm1a.fbg.sim.avgdeg) #43.66728
sd(g.ergm1a.fbg.sim.avgdeg) #0.05240351

mean(g.ergm1a.fbg.sim.avgbtwcen) #3805.712
sd(g.ergm1a.fbg.sim.avgbtwcen) #8.757621

mean(g.ergm1a.fbg.sim.avgclocen) #8.285989e-05
sd(g.ergm1a.fbg.sim.avgclocen) #8.353233e-06

mean(g.ergm1a.fbg.sim.avgeigveccen) #0.04179492
sd(g.ergm1a.fbg.sim.avgeigveccen) #0.0008307558


## two parameters: edges and triangles 
# set the seed for reproducible analysis 
set.seed(499)

# model 2a
# WARNING: takes time (20 iterations)
g.ergm2a.fbg <- ergm(fbg ~ edges + triangle)

numsim = 1000
set.seed(499)

g.ergm2a.fbg.sim.ecount <- rep(NA, numsim)
g.ergm2a.fbg.sim.coef <- rep(NA, numsim)
g.ergm2a.fbg.sim.apl <- rep(NA, numsim)
g.ergm2a.fbg.sim.dia <- rep(NA, numsim)
g.ergm2a.fbg.sim.avgdeg <- rep(NA, numsim)
g.ergm2a.fbg.sim.avgbtwcen <- rep(NA, numsim)
g.ergm2a.fbg.sim.avgclocen <- rep(NA, numsim)
g.ergm2a.fbg.sim.avgeigveccen <- rep(NA, numsim)

for (i in 1:numsim) {
  #simulate graphs from ergms model one at a time
  #convert to igraph object
  g.ergm.fbg.sim.convert <- asIgraph(simulate(g.ergm2a.fbg, nsim = 1))
  
  #observe the network statistics for this simulated graph
  g.ergm2a.fbg.sim.ecount[i] <- 
    ecount(g.ergm.fbg.sim.convert)
  g.ergm2a.fbg.sim.coef[i] <- 
    transitivity(g.ergm.fbg.sim.convert, type="localaverage")
  g.ergm2a.fbg.sim.apl[i] <- 
    average.path.length(g.ergm.fbg.sim.convert)
  g.ergm2a.fbg.sim.dia[i] <- 
    diameter(g.ergm.fbg.sim.convert)
  g.ergm2a.fbg.sim.avgdeg[i] <- 
    mean(igraph::degree(g.ergm.fbg.sim.convert))
  g.ergm2a.fbg.sim.avgbtwcen[i] <- 
    mean(igraph::betweenness(g.ergm.fbg.sim.convert))
  g.ergm2a.fbg.sim.avgclocen[i] <- 
    mean(igraph::closeness(g.ergm.fbg.sim.convert))
  g.ergm2a.fbg.sim.avgeigveccen[i] <- 
    mean(igraph::eigen_centrality(g.ergm.fbg.sim.convert)$vector)
}

g.ergm2a.fbg.sim.df <- 
  as.data.frame(cbind(g.ergm2a.fbg.sim.ecount, g.ergm2a.fbg.sim.coef, 
                      g.ergm2a.fbg.sim.apl, g.ergm2a.fbg.sim.dia,
                      g.ergm2a.fbg.sim.avgdeg, 
                      g.ergm2a.fbg.sim.avgbtwcen, 
                      g.ergm2a.fbg.sim.avgclocen, 
                      g.ergm2a.fbg.sim.avgeigveccen))

mean(g.ergm2a.fbg.sim.coef) #0.4823232
sd(g.ergm2a.fbg.sim.coef) #0.001965885

mean(g.ergm2a.fbg.sim.apl) #3.052008
sd(g.ergm2a.fbg.sim.apl) #0.008639291

mean(g.ergm2a.fbg.sim.dia) #6.098
sd(g.ergm2a.fbg.sim.dia) #0.3008097

mean(g.ergm2a.fbg.sim.avgdeg) #44.54161
sd(g.ergm2a.fbg.sim.avgdeg) #0.03491666

mean(g.ergm2a.fbg.sim.avgbtwcen) #4140.19
sd(g.ergm2a.fbg.sim.avgbtwcen) #17.65641

mean(g.ergm2a.fbg.sim.avgclocen) #6.007678e-05
sd(g.ergm2a.fbg.sim.avgclocen) #1.513646e-05

mean(g.ergm2a.fbg.sim.avgeigveccen) #0.04103567
sd(g.ergm2a.fbg.sim.avgeigveccen) #3.577786e-05


## two parameters: edges and k-stars
# WARNING: takes time (18 iterations)
# set the seed for reproducible analysis 
set.seed(499)

# model 2b
g.ergm2b.fbg <- ergm(fbg ~ edges + kstar(3))

numsim = 1000
set.seed(499)

g.ergm2b.fbg.sim.ecount <- rep(NA, numsim)
g.ergm2b.fbg.sim.coef <- rep(NA, numsim)
g.ergm2b.fbg.sim.apl <- rep(NA, numsim)
g.ergm2b.fbg.sim.dia <- rep(NA, numsim)
g.ergm2b.fbg.sim.avgdeg <- rep(NA, numsim)
g.ergm2b.fbg.sim.avgbtwcen <- rep(NA, numsim)
g.ergm2b.fbg.sim.avgclocen <- rep(NA, numsim)
g.ergm2b.fbg.sim.avgeigveccen <- rep(NA, numsim)

for (i in 1:numsim) {
  #simulate graphs from ergm model one at a time
  #convert to igraph object
  g.ergm.fbg.sim.convert <- asIgraph(simulate(g.ergm2b.fbg, nsim = 1))
  
  #observe the network statistics for this simulated graph
  g.ergm2b.fbg.sim.ecount[i] <- 
    ecount(g.ergm.fbg.sim.convert)
  g.ergm2b.fbg.sim.coef[i] <- 
    transitivity(g.ergm.fbg.sim.convert, type="localaverage")
  g.ergm2b.fbg.sim.apl[i] <- 
    average.path.length(g.ergm.fbg.sim.convert)
  g.ergm2b.fbg.sim.dia[i] <- 
    diameter(g.ergm.fbg.sim.convert)
  g.ergm2b.fbg.sim.avgdeg[i] <- 
    mean(igraph::degree(g.ergm.fbg.sim.convert))
  g.ergm2b.fbg.sim.avgbtwcen[i] <- 
    mean(igraph::betweenness(g.ergm.fbg.sim.convert))
  g.ergm2b.fbg.sim.avgclocen[i] <- 
    mean(igraph::closeness(g.ergm.fbg.sim.convert))
  g.ergm2b.fbg.sim.avgeigveccen[i] <- 
    mean(igraph::eigen_centrality(g.ergm.fbg.sim.convert)$vector)
}

g.ergm2b.fbg.sim.df <- 
  as.data.frame(cbind(g.ergm2b.fbg.sim.ecount, g.ergm2b.fbg.sim.coef,
                      g.ergm2b.fbg.sim.apl, g.ergm2b.fbg.sim.dia, 
                      g.ergm2b.fbg.sim.avgdeg, 
                      g.ergm2b.fbg.sim.avgbtwcen, 
                      g.ergm2b.fbg.sim.avgclocen, 
                      g.ergm2b.fbg.sim.avgeigveccen))

mean(g.ergm2b.fbg.sim.coef) #0.3786565
sd(g.ergm2b.fbg.sim.coef) #0.001279854

mean(g.ergm2b.fbg.sim.apl) #2.850693
sd(g.ergm2b.fbg.sim.apl) #0.003085883

mean(g.ergm2b.fbg.sim.dia) #5.095
sd(g.ergm2b.fbg.sim.dia) #0.2933617

mean(g.ergm2b.fbg.sim.avgdeg) #44.0645
sd(g.ergm2b.fbg.sim.avgdeg) #0.05715313

mean(g.ergm2b.fbg.sim.avgbtwcen) #3736.415
sd(g.ergm2b.fbg.sim.avgbtwcen) #6.259627

mean(g.ergm2b.fbg.sim.avgclocen) #8.558362e-05
sd(g.ergm2b.fbg.sim.avgclocen) #6.024968e-06

mean(g.ergm2b.fbg.sim.avgeigveccen) #0.03923439
sd(g.ergm2b.fbg.sim.avgeigveccen) #0.0002047637


## three parameters: edges and triangles and k-stars
# WARNING: takes time (20 iterations)
# set the seed for reproducible analysis 
set.seed(499)

# model 3a
g.ergm3a.fbg <- ergm(fbg ~ edges + triangle + kstar(3))

numsim = 1000
set.seed(499)

g.ergm3a.fbg.sim.ecount <- rep(NA, numsim)
g.ergm3a.fbg.sim.coef <- rep(NA, numsim)
g.ergm3a.fbg.sim.apl <- rep(NA, numsim)
g.ergm3a.fbg.sim.dia <- rep(NA, numsim)
g.ergm3a.fbg.sim.avgdeg <- rep(NA, numsim)
g.ergm3a.fbg.sim.avgbtwcen <- rep(NA, numsim)
g.ergm3a.fbg.sim.avgclocen <- rep(NA, numsim)
g.ergm3a.fbg.sim.avgeigveccen <- rep(NA, numsim)

for (i in 1:numsim) {
  #simulate graphs from ergm model one at a time
  #convert to igraph object
  g.ergm.fbg.sim.convert <- asIgraph(simulate(g.ergm3a.fbg, nsim = 1))
  
  #observe the network statistics for this simulated graph
  g.ergm3a.fbg.sim.ecount[i] <- 
    ecount(g.ergm.fbg.sim.convert)
  g.ergm3a.fbg.sim.coef[i] <- 
    transitivity(g.ergm.fbg.sim.convert, type="localaverage")
  g.ergm3a.fbg.sim.apl[i] <- 
    average.path.length(g.ergm.fbg.sim.convert)
  g.ergm3a.fbg.sim.dia[i] <- 
    diameter(g.ergm.fbg.sim.convert)
  g.ergm3a.fbg.sim.avgdeg[i] <- 
    mean(igraph::degree(g.ergm.fbg.sim.convert))
  g.ergm3a.fbg.sim.avgbtwcen[i] <- 
    mean(igraph::betweenness(g.ergm.fbg.sim.convert))
  g.ergm3a.fbg.sim.avgclocen[i] <- 
    mean(igraph::closeness(g.ergm.fbg.sim.convert))
  g.ergm3a.fbg.sim.avgeigveccen[i] <-
    mean(igraph::eigen_centrality(g.ergm.fbg.sim.convert)$vector)
}

g.ergm3a.fbg.sim.df <- 
  as.data.frame(cbind(g.ergm3a.fbg.sim.ecount, g.ergm3a.fbg.sim.coef,
                      g.ergm3a.fbg.sim.apl, g.ergm3a.fbg.sim.dia, 
                      g.ergm3a.fbg.sim.avgdeg, 
                      g.ergm3a.fbg.sim.avgbtwcen, 
                      g.ergm3a.fbg.sim.avgclocen, 
                      g.ergm3a.fbg.sim.avgeigveccen))

mean(g.ergm3a.fbg.sim.coef) #0.4890789
sd(g.ergm3a.fbg.sim.coef) #0.001991055

mean(g.ergm3a.fbg.sim.apl) #3.056179
sd(g.ergm3a.fbg.sim.apl) #0.007902389

mean(g.ergm3a.fbg.sim.dia) #6.161
sd(g.ergm3a.fbg.sim.dia) #0.3677149

mean(g.ergm3a.fbg.sim.avgdeg) #44.51779
sd(g.ergm3a.fbg.sim.avgdeg) #0.03363215

mean(g.ergm3a.fbg.sim.avgbtwcen) #4148.404
sd(g.ergm3a.fbg.sim.avgbtwcen) #16.0654

mean(g.ergm3a.fbg.sim.avgclocen) #5.875202e-05
sd(g.ergm3a.fbg.sim.avgclocen) #1.503473e-05

mean(g.ergm3a.fbg.sim.avgeigveccen) #0.0410138
sd(g.ergm3a.fbg.sim.avgeigveccen) #3.450909e-05
```



\clearpage

----------------------------------------------------------------------------------------------
Network Statistic    Observed     Erdős-Rényi                   Watts-Strogatz
------------------ ------------ ----------------------------- -----------------------------
Transitivity        0.617        0.0108 $\pm$ 0.0001           0.0107 $\pm$ 9e-05
  
Avg. Path Length    4.338        2.606 $\pm$ 0.002             2.609 $\pm$ 0.0002           
  
Diameter            17           3.96 $\pm$ 0.21               3.95 $\pm$ 0.22
  
Degree Cen.         43.69        43.69 $\pm$ 0.14              43.45 $\pm$ 0.01 
  
Betweenness Cen.    2072.642     3242 $\pm$ 4                  3249.2 $\pm$ 0.4 
  
Closeness Cen.      8.88e-08     9.507e-05 $\pm$ 7e-08         9.494e-05 $\pm$ 7e-09 
  
Eigenvector Cen.    0.040        0.620 $\pm$ 0.022             0.6235 $\pm$ 0.0227       
------------------- ------------ ----------------------------- -----------------------------
Table: Comparisons of network statistics among graphs simulated from the Erdős-Rényi and Watts-Strogatz models and the observed network (estimate $\pm$ standard deviation) \label{tab:erwsdescstats}

----------------------------------------------------------------------------------------
Network Statistic     Observed    ERGM1a                     ERGM2a
------------------  ----------- -------------------------- -----------------------------
Transitivity        0.617       0.3696 $\pm$ 0.0012        0.4823 $\pm$ 0.0020
  
Avg. Path Length    4.338       2.885 $\pm$ 0.004          3.052 $\pm$ 0.009         
  
Diameter            17          5.216 $\pm$ 0.412          6.098 $\pm$ 0.035
  
Degree Cen.         43.69       43.66 $\pm$ 0.05           44.54 $\pm$ 0.03 
  
Betweenness Cen.    2072.642    3805 $\pm$ 9               4140 $\pm$ 18 
  
Closeness Cen.      8.88e-08    8.286e-05 $\pm$ 8.35e-06   6.01e-05 $\pm$ 1.51e-05 
  
Eigenvector Cen.    0.040       0.0417 $\pm$ 0.0008        0.041 $\pm$ 5e-05      

------------------- ----------- -------------------------- ----------------------------
Table: Comparisons of network statistics among graphs simulated from ERGMs (1a: edges and 2a: edges and triangles) and the observed network (estimate $\pm$ standard deviation) \label{tab:ergm1a2a}

--------------------------------------------------------------------------------------
Network Statistic     Observed    ERGM2b                     ERGM3a
------------------  ----------- -------------------------- -----------------------------
Transitivity        0.617       0.379 $\pm$ 0.001          0.489 $\pm$ 0.002
  
Avg. Path Length    4.338       2.851 $\pm$ 0.003          3.056 $\pm$ 0.008 
  
Diameter            17          5.095 $\pm$ 0.293          6.161 $\pm$ 0.368
  
Degree Cen.         43.69       44.06 $\pm$ 0.06           44.52 $\pm$ 0.03
  
Betweenness Cen.    2072.642    3736 $\pm$ 6               4148 $\pm$ 16
  
Closeness Cen.      8.88e-08    8.558e-05 $\pm$ 6.03e-06   5.88e-05 $\pm$ 1.50e-05

Eigenvector Cen.    0.040       0.0392 $\pm$ 0.0002        0.0410 $\pm$ 3e-05      
------------------- ----------- -------------------------- -----------------------------

Table: Comparisons of network statistics among graphs simulated from ERGMs (2b: edges and k-stars($3$) and 3a: edges, triangles, and k-stars($3$)) and the observed network (estimate $\pm$ standard deviation) \label{tab:ergm2b3a}

The first column of  `r ref("erwsdescstats", type = "table")`, `r ref("ergm1a2a", type = "table")`, and `r ref("ergm2b3a", type = "table")` shows the network statistics we are interested in. The second column of each table lists the true value of the statistics associated with the Facebook component. Each of the other cells contain an estimated network statistic and standard deviation under each model. For statistics such as average degree, we were interested in recording an average of the average values. Additionally, because each simulated graph will have approximately the same number of vertices, we, again, do not scale these values. 

Based on `r ref("erwsdescstats", type = "table")`, we see that the estimated average statistics for the Erdős-Rényi and Watts-Strogatz models are very similar to each other but are drastically different from many of the observed values of our Facebook network. This means that while the graphs generated from each model look very similar to each other, they look drastically different from our observed Facebook network. This comes as no surprise since the methods used to construct graphs under both models are very likely to generate almost the same number of vertices. We even see this in our simulation study; in the fourth row of `r ref("erwsdescstats", type = "table")`, the average degree estimate for both models was within one degree of the other. Additionally, in both constructions, we are adding the edges randomly, so they are almost always spread evenly throughout the $4039$ vertices. This means that additional features of the observed network, such as large clusters or degrees with high centralities, are likely to be missed by graphs generated from these two models. This is why the transitivity, average path length, and diameter for both models are much smaller than what was actually observed. 

Similarly, due to the random dispersal of edges throughout the network, there is little control in deciding which vertices and how many are considered important, making the average centrality measures for the random graphs much larger than those seen in the observed model. The only statistic whose value was actually close to, if not equal to, the observed value was the average degree. However, this makes sense since we fixed the probability $p$ of a link forming in the Erdős-Rényi model (which is directly proportional to the average degree) and because we ensured that every graph generated from the Watts-Strogatz model has about the same number of edges as the observed network. Thus, we have shown through this simulation study that the Erdős-Rényi and Watts-Strogatz models are not very accurate in modeling our Facebook network for these particular network statistics. 

As `r ref("ergm1a2a", type = "table")` and `r ref("ergm2b3a", type = "table")` suggest, it appears that the random graphs generated from ERGMs provide very good estimates of average degree and average eigenvector centrality. Estimates of other network statistics, however, are quite different from what is actually observed. Not surprisingly, many of the average network statistics of the random graphs generated by the ERGMs get closer to the observed value as the number of parameters increase. This includes an overall increase in transitivity, average path length, and diameter and an overall decrease of average closeness centrality as the number of parameters increase from one to three. Average betweenness centrality, however, continues to drift farther away from the observed value as the number of parameters increase. 

The fact that ERGM 2a (edges and triangles) has such similar values to ERGM 3a (edges, triangles, and k-stars of size $3$) in spite the difference in the number of parameters suggests that the k-star parameter may be redundant. This is also further suggested by the fact that ERGM 2b (edges and k-stars of size $3$) and ERGM 1a (edges) are also very similar in values as well. While this simulation study suggests that the right combinations of parameters could potentially allow for an ERGM to accurately model an observed network, we conclude that the four ERGMs used in this study do not do a very good job of modeling our Facebook network for these particular network statistics. 

